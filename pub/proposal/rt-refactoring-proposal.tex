\documentclass[preprint,10pt]{sigplanconf}

\newcommand{\todo}[1]{{\bfseries [[#1]]}}
%% To disable, just uncomment this line
%% \renewcommand{\todo}[1]{\relax}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{CSE503}{'11 Seattle, USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Real-time Refactoring Recommendations}
% 1st. author
\authorinfo{Travis Mandel}
           {University of Washington}
           {tmandel@cs.washington.edu}
% 2nd. author
\authorinfo{Todd W. Schiller}
           {University of Washington}
           {tws@cs.washington.edu}
\maketitle
\begin{abstract}
An Eclipse plugin for providing real-time refactoring suggestions
\end{abstract}

\category{D.2.6}{Software Engineering}{Programming Environments}

\keywords{refactoring, recommender system, code clones}

\section{Introduction}

An Eclipse plugin for providing real-time refactoring suggestions.

As the programmer codes, we will analyze their code to determine where refactoring is needed. We plan to start with method extraction:That is, determining when your code duplicates functionality found elsewhere, so that we can suggest to the programmer that the duplicates be extracted into a method.

More concretely, we will search through the previous codebase for code that looks like a good match (text-based or otherwise)  to the region you are  currently working on.  Once we have identified the clones, we will score them with how difficult/worthwhile they would be to extract (for example, this could be based on length of the duplicate, or how many parameters the method would require).  If the score passes a threshold, we present the refactoring suggestion to the user.  We could do some simple machine learning here to make sure we reduce the false positives if the user rejects our suggestions.

The chief benefit is, at least for novice/rushed programmer, often they duplicate functionality in multiple places because they aren't aware of the other locations the code is written, or they can't be bothered finding them.  It is much more useful to present these suggestions as the user is writing them instead of after the fact, as it cuts down on time spent rewriting code, helps with code maintenance, and can help prevent certain kinds of bugs (there may be more defensive programming used in one of the clones but not the other).

We plan to evaluate based on user studies to determine how helpful our suggestions are.  Each user will be presented with an unfamiliar codebase and asked to implement a new method involving several   We will record how many false positives there are, how many accepted suggestions there are, and how many times the user uses a method we extracted. We will record amount of code typed and amount of time spent. We will poll users after the fact to ask them how helpful they found the tool.

\section{Related Work}

Some related work~\cite{Roy2009}.

\section{Conclusion}

Some concluding remarks

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{rt-refactoring-proposal,bibstring-abbrev,ernst,invariants,types}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
\end{document}
