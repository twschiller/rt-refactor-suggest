\documentclass[preprint,10pt]{sigplanconf}

\usepackage{url}

\newcommand{\todo}[1]{{\bfseries [[#1]]}}
%% To disable, just uncomment this line
%% \renewcommand{\todo}[1]{\relax}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{CSE503}{'11 Seattle, USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Real-time Code Clone Refactoring Recommendations}
% 1st. author
\authorinfo{Travis Mandel, Todd W. Schiller, Michael D. Ernst}
           {University of Washington}
           {\{tmandel,tws,mernst\}@cs.washington.edu}

\maketitle
\begin{abstract}
Code clone detection and analysis has historically been viewed as a
maintenance problem. Recently, tools for managing clones during
development have been introduced, however, these tools require
users to maintain formal clone models.
In this paper we propose a tool evaluation for (1) eliminating the
introduction of code clones during development without maintaining formal clone models, and (2) leveraging code
similarity to boost programmer productivity.

The tool
is an Eclipse plugin providing real-time clone detection and action
suggestions to the developer as (s)he writes and modifies
code. If time allows, machine learning will be 
employed to provide more pertinent results
and suggestions to the developer.
\end{abstract}

\category{D.2.6}{Software Engineering}{Programming Environments}

\keywords{refactoring, recommender system, code clones}

\section{Introduction}
\label{sec:intro}
Numerous studies suggest that code clones impair the maintainability
of software.

Yamashina et al. found in a sliding window analysis of a commercial CAD
application that 79.3\% of commits included modifications to files
containing code clones, but that only 9.7\% of such commits included
modifications to files containing the other
clones suggesting some clones may have erroneously not been updated
~\cite{Yamashina2008}. 
In a study of a commercial product line, Li and Ernst report that 4\%
of bugs were duplicated across at least one product or file;
additionally, they identified 282, 44, and 33 duplicated bugs in the
Linux kernel, Git, and PostgreSQL respectively~\cite{LiE2011}.

%Additionally, they report tenuous
%evidence from interviews and observation both novice and experience
%developers have difficuly finding code clones (the latter when
%identifiers have changed), and that novice developers do not
%systematically find all code clones before beginning to make
%revisions.

Under the assumption that code clones are not maintained properly,
Jeurgens et al. built a static bug detection tool based on
inconsistencies in clones, and confirmed that clones were a major
source of bugs in the studies subject programs~\cite{Juergens2009}.
Similarly, we hypothesize that when a developer (un)intentionally
nearly duplicates the functionality of an existing piece of code, without
referencing the original source, that the new code is more likely to
contain bugs than the original as it has not been tested or used in
production.

Code clones have historically been viewed as a problem of software
\emph{maintenance}, as failure to revise a clone can be an error. 
Or, the task of identifying code clones is considered a separate and
independent development task, and thus may not be performed in a
manner consistent with eliminating bugs.

In addition to helping developers \emph{maintain} clones, this work
aims to help developers \emph{develop} more effectively by
facilitating actions in the presence of system clones, existing code
that is a (partial) clone of the source under development:

\begin{enumerate}
  \item Replacing the code under development with a method call
  \item Extracting all, or part, of the system clone as a method;
    replacing the code under development with a call to the extracted
    method;
  \item Aiding the user making analogous changes to the system clones
    by opening the relevant sections of code, and potentially
    supporting ``simultaneous editing''~\cite{Miller2002};
  \item Copying the system clone to the code under development,
    substituting identifiers as needed.
\end{enumerate}

All four actions reduce development cost due to rewriting and
debugging duplicated code, while \#1-3 reduce maintenance costs;
unifying unifying code written by multiple developers may also improve
code consistency, readability, and modularity.

Unlike other recent work for managing code clones during
development~\cite{deWit2009, Duala-Ekoko2007}, the tool does not
require the developer to manage a formal model of the clone linkages;
as the tool does not depend on explicitly tracked linkages, clones can
be identified as they are being developed to inform developer actions,
even if the developer does not perform a copy-paste action or
explicitly perform a clone search query.

This paper proceeds as follows: section~\ref{sec:finding-clones}
describes the user interface for the tool, along with the underlying
clone detectors. Section~\ref{sec:eval} proposes a controlled user
study to evaluate the tool. Section~\ref{sec:related} discusses
related work in clone detection, analysis, and refactoring. Finally,
Section~\ref{sec:conclusion} concludes.

\section{Finding Clones}
\label{sec:finding-clones}

% Don't use ``we'' to refer to the tool. The tool is the tool.

%As the programmer develops, the tool will analyze the code to
%determine the location of code clones, to aid in refactoring (method
%extraction), method calls, or copying. In the future, the tool could
%be extended to other refactorings / uses.

To support the developer actions enumerated in section~\ref{sec:intro},
the tool will search the existing codebase for code
that is similar to the region that is currently being developed or maintained
(i.e. where the cursor is). The search is performed using the clone detectors
described in section~\ref{sec:detectors}. The clone detection is implemented as
an Eclipse reconciler, which allows it to run in a background thread and only activate 
when there is a natural pause in typing.

In order to be practical in an online
setting with a large codebase, the detectors must be
fast and
robust to identifying clones that are more obfuscated than direct
copying, such as when a programmer re-implements the same
functionality.
%without referring to the first code section.

\subsection{Clone Detectors}
\label{sec:detectors}
The tool is currently packaged with three code clone detectors:

\begin{enumerate}
\item The Java Code Clone Detection (JCCD) API~\cite{JCCD}: performs
  AST-based similarity detection with support for a pipeline of AST
  operators; requires that the source files are parsable.
\item Checkstyle~\cite{CheckStyle}: performs a textual comparison on
  the lines of a program
\item Simian~\cite{Simian}: the Simian software is proprietary (though
  free for non-commercial use), but it appears the Simian can perform
  both textual and AST-based detection.
\end{enumerate}

All three detectors perform detection over the entire codebase, as
opposed to searching for clones for a given query. The speed of JCCD
and Checkstyle may not be practical for real-time detection in large
projects. Since both are open source, we can and will optimize the
detection for use in our tool, if necessary.  

%% TWS: the big-O analysis isn't correct, and I don't believe this adds anything
%% Such optimization could potentially involve exploiting knowledge of the 
%% modified code region to drastically reduce the complexity of the search,
%%  since instead of comparing all pairs of potential clones with $O(N^2)$, 
%% we would only need $O(N)$ comparisons to detect the clones. Currently, 
%% we only annotate clones located in the currently modified area, but
%% that is implemented as a filter instead of an algorithmic change.

We have been in contact with Li et al.~\cite{LiE2011} to apply program
dependence graph (PDG) approaches to clone search, however at this
time our search for a tool for generating detailed Java PDGs has been
unsuccessful.

Currently, only a single detector can be active at a time. In the
future, it may be beneficial to run the analyses simultaneously and
combine results.

\subsection{Determining When to Make Suggestions}
The tool will score the clone based on a variety of heuristics that
capture the value of the clone for method extraction or copying:

\begin{itemize}
  \item length of the code clone
  \item number of parameters in the extracted method
  \item module distance (how far away the clone is in the code base)
  \item how complete the current code section is
\end{itemize}

If the score exceeds a threshold, the tool will present the 
clone suggestions to the user, along with potential refactoring options.  
In many cases it may suffice simply to show actions based on the "top 
hit", but in others it may be helpful to show a larger ranking.  The detected 
areas in the current file will be displayed as Eclipse annotations, which take 
the form of highlighting with a marker icon on the left vertical bar and a 
colored marking on the right vertical bar.  When users click the left marker,
the corresponding clone(s) and potential refactoring options will be shown, 
similar to Eclipse's quickfix functionality for resolving errors and warnings.

Time permitting, we also plan to investigate, in place of a 
fixed threshold, simple machine learning strategies to ensure the
false positives are reduced if the user frequently rejects the tool's
suggestions.  This will take the form of a classifier using the
heuristics as input, and may be trained on each individual user to
account for different programming styles.

\section{Evaluation}
\label{sec:eval}

%We plan to evaluate based on user studies to determine how helpful our
%suggestions are.  Each user will be presented with an unfamiliar
%codebase and asked to implement a new method involving several We will
%record how many false positives there are, how many accepted
%suggestions there are, and how many times the user uses a method we
%extracted. We will record amount of code typed and amount of time
%spent. We will poll users after the fact to ask them how helpful they
%found the tool.

We will evaluate the tool via controlled user study. Each user will be given
a series of development and maintenance tasks for an existing Java
code base. Subjects will be provided with a suite of unit tests covering the
entire codebase (and their new development task) which must all pass
before the task is considered complete.
\todo{Characterize the tasks and code base} 
\todo{How are we going to direct users toward creating or maintaining
  clones?, or will the code base already have clones?}

The control group will use the stock Eclipse development
environment, the tool group will use the Eclipse development
environment with the tool. For the initial study for CSE 503, each
group will consist of two individuals who have experience using the
Java development environment.  

Subjects will be instructed that they ``own'' the code base, that is they
have permission to introduce new methods, but must document the
methods.  

\subsection{Quantitative Evaluation}
For the development tasks, we will measure the time to complete the
task, the number of times the the tool detects a code clone (or would
detect a clone, for the control group),
the number of methods extracted, and the number of code clones
introduced into the code base, and percentage of the new code that is
a clone of other code. 
For the control group, we will additionally
record the number of times the developer searches for a method that
performs a subtask. 
For the tool group, we will record the number of
times the user ignores the tool's
alert, the user views the tool's analysis, and the user acts on the
tool's analysis. Additionally, when the user acts on the tool's
analysis, we will record the ranking of the clone the user acted on.

For the maintenance tasks, we will measure the time to complete the
task, and whether the user has correctly revised all of the clones (as
determined by hidden test suite). We will record the same
group-specific metrics as for the development tasks.

\subsection{Qualitative Evaluation}
In addition to the quantitative results, we will have the study
participants respond to the following questions:

\begin{itemize}
  \item If you extracted a method, how did you decide to extract the
    method? 
  \item If you chose not to extract a method, why did you decide not
    to extract the method?
\end{itemize}

\noindent Additionally, the treatment group will respond to the following
questions:

\begin{itemize}
  \item Did you find the tool's suggestions helpful? If not, why?
  \item Was the ordering of the tool's suggestions valid? If not, why?
\end{itemize}

\subsection{Threats to Validity}
The evaluation outline in this section is meant as a preliminary study
to investigate the efficacy of the tool --- it is not meant to be
conclusive. That being said, this study, and potentially larger
studies of the same design have the following potential threats to
validity:

\begin{itemize}
  \item The study participants do not have to maintain the code in the
    future, and are therefore may be more likely to perform a
    short-sighted action
  \item The results may not generalize, as in real software there may
    be de facto or de jure restrictions (e.g., a certain module cannot
    be changed) restricting the set of actions a user can make
  \item This tool seems especially helpful if it suggests that a
    developer is cloning code which that developer personally wrote in the
    past.  Due to time limitations this scenario may be difficult to
    induce, as it usually occurs after one has been working on the
    same project for a long time.
\end{itemize}

We believe that the first threat can be mitigated via instructions to
the study participants. The second factor may require an additional
investigation where such restrictions are in place.  The third factor
requires a long-term study over weeks, months, or years.

\section{Related Work}
\label{sec:related}

The code clone literature can be divided into two areas: (1)
\emph{post} hoc code clone detection, maintenance, and detection and
(2) \emph{propter} hoc clone management. The techniques used in the
former can vary wildly based on subject (i.e., plain-text v. code) and
purpose (software development v. plagiarism) but typically utilize an
ad hoc model of clones. In contrast, the latter literature focuses on
the creation and maintenance of formal code clone models during the
development process.

Roy et al provide a survey of code clone detection
techniques~\cite{Roy2009}. The rest of this section surveys the
related work on recommender systems, clone refactoring,
 code clone interfaces, and \emph{real-time} code clone detection.

\paragraph{Post-hoc Clone Maintenance and Refactoring}

Visual Studio Ultimate contains a code clone detection tool and
interface; the tool can be run on a particular code fragment, or over
the entire solution~\cite{VSClones}. 
%Other commercial products and
%academic artifacts exist which provide different interfaces /
%visualizations.

%TWS: 2 papers 10 years apart isn't really significant
%There has been significant research in how to refactor code containing clones
%to improve code maintenance and readability.  

Fanta and Rajlich propose a number of
potential refactorings for clones including function insertion and function encapsulation,
in part proposing certain clones be extracted into methods \cite{Fanta1999}.  They 
present a case study for a C++ project which demonstrates that code refactoring is an important 
addition to clone detection.

Higo et al. present Aries, a tool which integrates various clone
information to present to the user \cite{Higo2008}.  The tool displays the
cloned blocks of code and presents refactoring options such as method
extraction; it augments the options with various metrics, including position in
the class hierarchy, and number of external variables. These metrics
are intended to help the programmer decide which refactoring, if any,
is appropriate.

Kawaguchis et al. present a  
Microsoft Visual Studio interface for
displaying code clones in real-time to support software
\emph{maintenance} tasks~\cite{Kawaguchi2009,Yamashina2008}. Their
\textsc{Shinobi} system uses the CCFinderX's preprocessor and the Suffix Array
technique for indexing clones. Displayed clones are ranked via the sum
of the ratio files committed at the same time and the ratio of files
opened or edited at the same period in Visual Studio. \todo{How do
  they get the latter piece of information?}

\paragraph{Development-time Clone Management}

From a user-interface stand-point, perhaps the work most similar to
ours is de Wit et al.'s \textsc{CloneBoard} Eclipse plugin that tracks
clone created by copy-paste operations~\cite{deWit2009}. Inspired
by~\cite{Mann2006}, the plugin registers code from copy-paste
operations as clones and prompts the developer with a set of actions
when the clone is modified: parameterize clone, unmark clone's tail,
unmark clone's head, postpone resolution, unmark clone, apply changes
to all clones, ignore changes. Inconsistent clones are identified via
a red marker on the left-column of the editor. Unlike our tool, only
clones arising from copy-paste operations are tracked, and the
developer explicitly manages the clone linkages.

Duala-Ekoko et al. present \textsc{CloneTracker}, an Eclipse plugin
for managing code clones that abstracts groups of clones via clone
region descriptors (CRDs) to track clones across software
versions~\cite{Duala-Ekoko2007}. The tool requires users to explicitly
create tracked clone groups by ``documenting'' a group of results from
the SimScan clone detection tool. \textsc{CloneTracker} additionally
supports simultaneously editing clones. However, in the author's
trials, the success rate of this feature to correctly modify the
clones was 80\%.

\paragraph{Recommender Systems}

Holmes and Murphy built the Strathcona tool for Eclipse which displays
relevant API usage examples to a user based on the structural context
of a query line(s) of code the user selects in the IDE
\cite{Holmes2005}. Related systems also exist, but require the user to
perform a formal query, or to write special comments in the code.

\paragraph{Real-time Code Clone Search}

Applying code clone analysis during development places speed demands
on the detection algorithms. However, the need to only perform clone
detection in a single direction provides many opportunities for
speedup.

Keivanloo et al. describe SeClone, a system for Internet code clone
search that performs clone pair clustering based on a ontology base on
features such as similarity~\cite{Keivanloo2011}. Similar to CCFinder,
it preprocesses files by generating the AST and abstracting the
tokens. The code patterns are used to quickly perform search, false
positives are limited by a retained set of type information. Results
are clustered via file-level type information.

Lee et al. introduce a method for instant structural code clone search
over large repositories by utilizing an R*tree indexing structure over
the characteristic vectors~\cite{Lee2010}.

\section{Conclusion}
\label{sec:conclusion}

In the past, code clones detection and analysis has been viewed as a
maintenance problem. 
%TWS: We haven't substantiated the following claim anywhere:
%We believe the problems code clones pose are 
%more serious, especially those that are re-written instead of being a 
%"copy and paste".  
We have proposed a tool and evaluation for
eliminating the introduction of code clones during development, and
leveraging similar code to boost programmer productivity and improve
code robustness and organization.

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{rt-refactoring-proposal,bibstring-abbrev,ernst,invariants,types}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
\end{document}
